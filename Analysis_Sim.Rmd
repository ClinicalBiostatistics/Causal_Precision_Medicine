---
title: "Precision medicine and causality - Simulation study V7"
author: "Jonas BÃ‰AL"
date: "11/15/2019"
output:
  html_document:
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Paths
original_path <- normalizePath(getwd())
base_folder <- dirname(original_path)
knitr::opts_knit$set(root.dir = base_folder,fig.align='center')

#Packages
if (!require("pacman")) install.packages("pacman")
list.of.packages <- c("tidyverse", "paletteer", "magrittr",
                 "eulerr", "ggpubr", "egg", "ggstance", "ggalluvial",
                 "factoextra", "FactoMineR", "ggrepel",
                 "lava", "ggplot2", "cowplot", "Publish", "patchwork",
                 "nnet", "DescTools", "tictoc", "kableExtra", "latex2exp")
pacman::p_load(list.of.packages, character.only = TRUE)
select <- dplyr::select
theme_set(theme_pubclean())
tic()
```

This notebook accompanies the article entitled:

> Causal inference with multiple versions of treatment and application to personalized medicine

It contains the investigation on simulated data referenced as section 4 of the article. Please note that an interactive RShiny app has been designed to ease the simulation of various simulation scenarios. This application is available on the same [GitHub repository](https://github.com/JonasBeal/Causal_Precision_Medicine).

# Objectives and methods

We want to perform a quantitative evaluation of precision medicine (PM) strategies with observational data. So we will emulate target trials in the potential outcomes framework in order to estimate our causal effects of interest.

## Target trials

![Target trials to estimate causal effect of precision medicine (PM) algorithm versus different controls. Patients are first screened according to their eligibility for the algorithm: based on their genomic characteristics patients are recommended a specific treatment (eligible) or not (no eligible). Then eligible patients are randomized and assigned either to PM-directed arm or to one of the alternative control arms (CE_1, CE_2 or CE_3)](Manuscript PreMedCaus/Pictures/Target_Trials.png)

We define 3 different target trials comparing a precision medicine arm with 3 different control arms therefore defining 3 different causal effects CE1/CE2/CE3.

Our first causal effect of interest *quantifies the effect of PM versus a simple control*, called **CE1** in this document. In practice, this causal effect corresponds to the expected gain compared a single-version reference/standard of care. This reference treatment can also be understood as the absence of treatment in some cases.

Our second causal effect of interest *quantifies the PM improvement compared to the treatments effectively given in the real cohort, i.e. the physician's choice*, called **CE2** in this document. We assume that treatment assignments in observational data have their own rationale and we compare our PM algorithm to this rationale. In practice, this causal effect compare the validity of treatment assignment in the observational data and the potential re-assignement of treatments that would have been performed by the PM algorithm.

Our third causal effect of interest is to *quantify the relevance of treatment assignment, i.e the potential improvement of PM treatment assignement compared to a random assignment of the same versions of treatment*, called **CE3** in this document. 

All these effects are defined only for PM-eligible patients, i.e for patients whose mutations results in a personalized treatment recommendation. For non-eligible patients it does not make sense to quantify the impact of the PM algorithm and to compare it with a control.

## Potential outcomes framework

We will use the potential outcomes framework to estimates the causal effects described in previous section with observational data. Below, we summarize very briefly the variables we use to model our precision medicine settings. Please refer to the article for a detailed description of potential outcomes framework, counterfactual variables and the impact of the multiplicity of versions of treatment.

![Causal diagram in Precision Medicine](Manuscript PreMedCaus/Pictures/DAG_multiple.png)

We have:

  * **C**, the patient covariates, in our case mainly some biomarkers based on mutations that can help define the best personalized treatment. 
<!--**W** is another kind of biomarker confusing uniquely the relation betwwen A and K. We will have no W-type covariates in the present simulation--> 
  * **A**, the treatment status, in our case hase the patient been treated with an anti-cancer drug ($A=1$) or with the control treated/left untreated ($A=0$)
  * **K**, the versions of treatment, in our case the precise drug given to the patient. For $A=1$, K will be one of the three possible personalized drug, $\mathcal{K}^{1} = \{k^{1,1}, k^{1,2}, k^{1,2}\}$. More simply, $\mathcal{K}^{0}=\{k^0\}$ depends on the definition of the controls
  * **Y**, the treatment strategy outcome, like tumour size

## Simulated data

In order to assess the relevance of our proposed methods we simulate data. Doing so, we will be able to compare what we estimate with simulated observational data with ground truth, since we will access also counterfacual values. We will generate simulated data with the R package **lava**.

Here, we will describe the general architecture of our simulated datasets. Then, in the next section we will apply our methods to different cases derived from this architecture, varying some parameters or relations in order to better characterize the behaviour of the method and the potential biases.

We first define the following variables:

  * **C_1** and **C_2** are two different C covariates. In terms of interpretation they correspond to mutation status for two different genes ($C_i=1$ when mutated, $C_i=0$ otherwise). These mutations status are the biomarkers used in the PM algorithm
  * **A** is the treatment status as explained above.
  * **K** is the observed version of treatment. For untreated patients there is only one version *k_0*. For treated patients we observe two different version *k_1*, *k_2* (*k_i* being a simplified notation for what has been defined in the article as $k^{1,i}$). The precise distribution of these observed version of treatment corresponds to drug assignment by physicians in the observational data. **K_PM** is the version of treatment recommended to the patient by the PM algorithm, i.e. according to the notations in the article, $K^{PM}=r(C)$. In the following simulation, the PM algorithm is defined with the following rule
    + If $C_1=1$ and $C_2=0$ --> k_1
    + If $C_2=1$ and $C_1=0$ --> k_2
    + If $C_1=1$ and $C_2=1$ --> k_1
  * We also defined all the counterfactual outcomes **Y_0** (simplified notation for $Y(0,k^0)$), **Y_1** (simplified notation for $Y(1,k^1)$), **Y_2** (simplified notation for $Y(1,k^2)$). Then we can define **Y**, the observed outcome, i.e. the real outcome in the observational data, resulting from treatment by **K**. And similarly **Y_PM**, the PM outcome, i.e. the outcome that would have been observed had the patient been treated by **K_PM**. THerefore this variable is defined only for patients eligible to PM. All outcome variables are defined gaussian. By analogy with later used PDX data, Y is interpreted as the evolution of tumour volume and a low number (a fortiori negative) corresponds to a better response. Their relations of dependance regarding C and K variables wil be defined specifically in each subsequent case.
  * $Aggressiveness$ is a latent variable to take into account the different stages of oncogenesis. It obviously influences all the outcomes

In each one of the following cases, we will:

  * define a latent model structure with specific properties and relations between variables
  * illustrate the structure of data with a plot of the latent model
  * generate a super-populations of 10 000 patients
  * provide a comprehensive description of the simulated dataset
  * randomly sample 1000 cohorts of 200 patients and compute our effects CE1, CE2 and CE3 in each one of these sub-cohorts on order to compare the distribution of our estimates with true effects
  * analyse the results with some plots 

# Define functions 

In this section we define the functions used in later visualisations and computations

## Visualize nature of simulated data

We define the function *simulated_data_plot* to generate a synthetic plot of the nature of simulated data.

```{r sim_data_plots, echo=FALSE, fig.height=8, fig.width=16, message=FALSE, warning=FALSE}
#Colors
#wesanderson::wes_palettes$Cavalcanti1
colors_genes <- c("C_1"="#972D15", "C_2"="#02401B","C_3"="#D8B70A")

colors_drugs_NE <- c("k_1"="#972D15", "k_2"="#02401B","k_3"="#D8B70A", "Not eligible"="grey30", "None"="grey30")

colors_drugs <- c("k_1"="#972D15", "k_2"="#02401B","k_3"="#D8B70A", "k_0"="grey50")

colors_drugs_sankey <- c("K_PM=k1"="#972D15", "K_PM=k2"="#02401B","K_PM=k3"="#D8B70A", "K_PM=None"="grey70")

simulated_data_plot <- function(df){
  #Prepare data
  sim_data <- df %>% rename_all(funs(str_replace(., "C_", "C")))
  sim_data$set = apply(sim_data %>% select(C1, C2), 1,function(x) {
    paste(sort(names(x)[which(x == 1)]), collapse="-")
  })
  
  # Add a "None" genre
  sim_data$None=ifelse(sim_data$set=="", 1, 0)
  sim_data$set[sim_data$set==""] = "None"
  
  # Get order of genre groupings 
  set_order = sim_data %>% group_by(set) %>% 
    summarise(n = n()) %>%
    mutate(Drug_PM=case_when(
      set=="C1" ~ "k_1",
      #set=="C1-C3" ~ "k_1",
      #set=="C1-C2-C3" ~ "k_1",
      set=="C2" ~ "k_2",
      set=="C1-C2" ~ "k_1",
      #set=="C3" ~ "k_3",
      #set=="C2-C3" ~ "k_3",
      set=="None" ~ "None"
    )) %>%
    #mutate(Drug_PM=c("k_1", "k_2", "k_1", "k_1", "k_2", "k_3", "k_3", "None")) %>%
    arrange(Drug_PM) %>%
    mutate(set = factor(set, levels=set),
           prop=round(n/sum(n), digits=3),
           pos=NA)
  
  set_order$pos[1] <- set_order$prop[1]/2
  for(i in 2:nrow(set_order)){
    set_order$pos[i] <- sum(set_order$prop[1:(i-1)])+set_order$prop[i]/2
  }
  
  # Set order of genre groupings
  sim_data = sim_data %>% 
    mutate(set = factor(set, levels=set_order$set))

  tile_categories = sim_data %>% 
    gather(key, value, C1, C2) %>% 
    group_by(set, key, value) %>% 
    slice(1) %>% 
    ungroup %>% 
    mutate(key = factor(key)) %>% 
    left_join(set_order, by="set") %>%
    ggplot(aes(x=key, y=pos, height=prop)) +
    geom_tile(aes(fill=Drug_PM, alpha=as.factor(value)), color="white")  +
    geom_text(aes(label=ifelse(value==1, substr(key,1,2), "")), colour="white", size=3,fontface = "bold") +
    theme_classic() + 
    theme(axis.title.x=element_blank(), plot.title = element_text(hjust = 0.5)) +
    scale_fill_manual(values=colors_drugs_NE) +
    scale_alpha_manual(values = c(0.2,1)) +
    scale_y_continuous(breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1), label = c("0", "2k", "4k", "6k", "8k", "10k")) +
    labs(x= "Genes",
         y = "Number of patients and\ncombinations of mutations") +
    guides(fill=FALSE, alpha=FALSE)
  
  #Boxplots
  plot_BP_Y0 <- left_join(sim_data, select(set_order, set, pos, n), by="set") %>%
    ggplot(aes(x=Y_0, y=pos, group=pos)) +
    geom_boxploth(aes(weight=sqrt(n)), fill="grey50", alpha=0.2,
                  show.legend = F, varwidth = T, width=0.15) +
    ylim(c(0,1)) +
    theme_classic() + 
    theme(axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          plot.margin=margin(r=-2),
          plot.title = element_text(hjust = 0.5)) +
    labs(x=TeX("$Y(0, k^0)$"))
  
  plot_BP_Y1 <- left_join(sim_data, select(set_order, set, pos, n), by="set") %>%
    ggplot(aes(x=Y_1, y=pos, group=pos)) +
    geom_boxploth(fill="grey50", aes(alpha=as.factor(C1), weight=sqrt(n)),
                  show.legend = F, varwidth = T, width=0.15) +
    scale_alpha_manual(values = c("0"=0.2,"1"=1)) +
    ylim(c(0,1)) +
    theme_classic() + 
    theme(axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          plot.margin=margin(r=-2),
          plot.title = element_text(hjust = 0.5)) +
    labs(x=TeX("$Y(1, k^1_1)$"))
  
  plot_BP_Y2 <- left_join(sim_data, select(set_order, set, pos, n), by="set") %>%
    ggplot(aes(x=Y_2, y=pos, group=pos)) +
    geom_boxploth(fill="grey50", aes(alpha=as.factor(C2), weight=sqrt(n)),
                  show.legend = F, varwidth = T, width=0.15) +
    scale_alpha_manual(values = c("0"=0.2,"1"=1)) +
    ylim(c(0,1)) +
    theme_classic() + 
    theme(axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          plot.margin=margin(r=-2),
          plot.title = element_text(hjust = 0.5)) +
    labs(x=TeX("$Y(1, k^1_2)$"))
  
  plot_BP_YPM <- left_join(sim_data, select(set_order, set, pos, n), by="set") %>%
    ggplot(aes(x=Y_PM, y=pos, group=pos)) +
    geom_boxploth(aes(fill=as.factor(K_PM), weight=sqrt(n)),
                  show.legend = F, varwidth = T, width=0.1) +
    scale_fill_manual(values = colors_drugs) +
    ylim(c(0,1)) +
    theme_classic() + 
    theme(axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          plot.margin=margin(r=-2),
          plot.title = element_text(hjust = 0.5)) +
    labs(x=TeX("$Y(1, r(C))$"))
  
  #Sankey plot with ggalluvial
  # plot_sankey <- mutate(sim_data,
  #                       K=if_else(set=="None", factor("None", levels = c("k_1", "k_2", "k_0", "None")), K),
  #                       set=factor(set, levels = set_order$set) %>% fct_rev,
  #                       K_PM=fct_recode(K_PM, `K_PM=k1`="k_1",
  #                                       `K_PM=k2`="k_2",
  #                                       `K_PM=None`="None") %>%
  #                         factor(levels=c("K_PM=None",
  #                                         "K_PM=k2", "K_PM=k1")),
  #                       K=fct_recode(K, `K=k1`="k_1",
  #                                    `K=k2`="k_2",
  #                                    `K=k0`="k_0") %>%
  #                         factor(levels=c("None", "K=k0",
  #                                         "K=k2", "K=k1"))) %>%
  #   group_by(set, K_PM, K) %>%
  #   summarise(Freq=n()) %>%
  #   ggplot(aes(y = Freq, axis1 = set, axis2 = K_PM, axis3= K)) +
  #   geom_alluvium(aes(fill = K_PM), width = 1/3) +
  #   geom_stratum() +
  #   geom_text(stat = "stratum", label = c(paste0(set_order$prop*100,"%"),
  #                                         paste0("K_PM\n=\nk",1:2), "K_PM\n=\nNone",
  #                                         paste0("K=k",1:2), "K=k0", "None"),
  #             size=3) +
  #   scale_x_discrete(limits = c("% patients", "K_PM", "K"), expand = c(.01, .01)) +
  #   scale_fill_manual(values = colors_drugs_sankey,
  #                     guide = guide_legend(direction = "horizontal")) +
  #   theme(legend.position = "right",
  #         legend.title = element_text(face="bold", size=10),
  #         legend.text = element_text(size=8),
  #         axis.title.y=element_blank(),
  #         axis.text.y=element_blank(),
  #         axis.line.y=element_blank(),
  #         axis.ticks.y=element_blank(),
  #         panel.grid = element_blank(),
  #         panel.grid.major.y = element_blank(),
  #         panel.background = element_blank()) +
  #   labs(fill="K_PM:")
  
  plot_sankey <- mutate(sim_data,
                        K=if_else(set=="None", factor("None", levels = c("k_1", "k_2", "k_0", "None")), K),
                        set=factor(set, levels = set_order$set) %>% fct_rev,
                        K_PM=fct_recode(K_PM, `K_PM=k1`="k_1",
                                        `K_PM=k2`="k_2",
                                        `K_PM=None`="None") %>%
                          factor(levels=c("K_PM=None",
                                          "K_PM=k2", "K_PM=k1")),
                        K=fct_recode(K, `K=k1`="k_1",
                                     `K=k2`="k_2",
                                     `K=k0`="k_0") %>%
                          factor(levels=c("None", "K=k0",
                                          "K=k2", "K=k1"))) %>%
    group_by(set, K_PM, K) %>%
    summarise(Freq=n()) %>%
    ggplot(aes(y = Freq, axis1 = set, axis2 = K_PM, axis3= K)) +
    geom_alluvium(aes(fill = K_PM), width = 1/3) +
    geom_stratum() +
    geom_text(stat = "stratum", label = c(paste0(set_order$prop*100,"%"),
                                          TeX("$k^1_1$"),
                                          TeX("$k^1_2$"), "None",
                                          TeX("$k^1_1$"),TeX("$k^1_2$"), TeX("$k^0$"), "None"),
              size=3) +
    scale_x_discrete(limits = c("% patients", "r(C)", "K"), expand = c(.01, .01)) +
    scale_fill_manual(values = colors_drugs_sankey,
                      guide = guide_legend(direction = "horizontal")) +
    theme(legend.position = "right",
          legend.title = element_text(face="bold", size=10),
          legend.text = element_text(size=8),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          panel.grid = element_blank(),
          panel.grid.major.y = element_blank(),
          panel.background = element_blank()) +
    labs(fill="K_PM:")
  
  plot_sankey <- mutate(sim_data,
                        K=if_else(set=="None", factor("None", levels = c("k_1", "k_2", "k_0", "None")), K),
                        set=factor(set, levels = set_order$set) %>% fct_rev,
                        K_PM=fct_recode(K_PM, `K_PM=k1`="k_1",
                                        `K_PM=k2`="k_2",
                                        `K_PM=None`="None") %>%
                          factor(levels=c("K_PM=None",
                                          "K_PM=k2", "K_PM=k1")),
                        K=fct_recode(K, `K=k1`="k_1",
                                     `K=k2`="k_2",
                                     `K=k0`="k_0") %>%
                          factor(levels=c("None", "K=k0",
                                          "K=k2", "K=k1"))) %>%
    rename(`r(C)`=K_PM) %>%
    group_by(set, `r(C)`, K) %>%
    summarise(Freq=n()) %>%
    ggplot(aes(y = Freq, axis1 = set, axis2 = `r(C)`, axis3= K)) +
    geom_alluvium(aes(fill = `r(C)`), width = 1/3) +
    geom_stratum() +
    geom_text(stat = "stratum", label = c(paste0(set_order$prop*100,"%"),
                                          TeX("$k^1_1$"),
                                          TeX("$k^1_2$"), "None",
                                          TeX("$k^1_1$"),TeX("$k^1_2$"), TeX("$k^0$"), "None"),
              size=3) +
    scale_x_discrete(limits = c("% patients", "r(C)", "K"), expand = c(.01, .01)) +
    #scale_fill_discrete(name = "r(C)", labels = c("NoneA", "k11B", "k12C")) +
    scale_fill_manual(values = colors_drugs_sankey,
                      guide = guide_legend(direction = "horizontal"),
                      name = "r(C):", labels = parse(text=c("k^0", "k[2]^{1}", "k[1]^{1}"))) +
    theme(legend.position = "right",
          legend.title = element_text(face="bold", size=10),
          legend.text = element_text(size=8),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          panel.grid = element_blank(),
          panel.grid.major.y = element_blank(),
          panel.background = element_blank())
  
  p <- ( guide_area() / ((tile_categories | plot_BP_Y0 | plot_BP_Y1 | plot_BP_Y2 | plot_BP_YPM | plot_sankey) + plot_layout(widths = c(2,3,3,3,3,8)))) +
    plot_layout(heights = c(1, 8), guides = 'collect')
  return(p)
}

print("Done")
```

## Compute causal effects

We define the function *random_cohorts* to compute all causal estimates with different methods.

```{r PM_random, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE}
#super_populations <- sim_data1
list_genes <- c("C_1", "C_2")
list_treatments <- c("k_1", "k_2")

true_effects <- function(df){
  df %<>% filter(!is.na(Y_PM)) %>%
    mutate(CE1=Y_PM-Y_0,
           CE2=Y_PM-Y,
           CE3=Y_PM-Y_Random)
  
  res <- data.frame(
    CE1=mean(df$CE1),
    CE2=mean(filter(df, A==1)$CE2),
    CE3=mean(df$CE3)
    )
  
  return(res)
}

random_cohorts <- function(super_populations, size_cohorts=200, number_cohorts=1000, bin=FALSE){
  
  if (bin==TRUE){
    fam <- binomial(link = "logit")
  } else {
    fam <- gaussian
  }
  
  #Define output object
  res <- data.frame(Cohort=1:number_cohorts,
                    CE1_True=NA_real_, CE1_Naive=NA_real_,
                    CE1_Std=NA_real_, CE1_IPW=NA_real_, CE1_TMLE=NA_real_, CE1_TMLEsl=NA_real_,
                    CE2_True=NA_real_, CE2_Naive=NA_real_,
                    CE2_Std=NA_real_, CE2_IPW=NA_real_, CE2_TMLE=NA_real_, CE2_TMLEsl=NA_real_,
                    CE3_True=NA_real_, CE3_Naive=NA_real_,
                    CE3_Std=NA_real_, CE3_IPW=NA_real_, CE3_TMLE=NA_real_, CE3_TMLEsl=NA_real_
                    )
    
    for (g in list_genes){
      res[,paste0("Prop_CE", 1:3, "_", g)] <- NA_real_
      res[,paste0("Diff_CE", 1:3, "_", g)] <- NA_real_
    }
    for (t in list_treatments){
      res[,paste0("Prop_CE", 1:3, "_", t)] <- NA_real_
      res[,paste0("Diff_CE", 1:3, "_", t)] <- NA_real_
    }
    
    #COHORTS: define the sampling sub-cohorts
    set.seed(1)
    sample_patients <- replicate(number_cohorts, sample(1:nrow(super_populations),
                                                        size_cohorts, replace = F),
                                 simplify = T)
    
    #LOOP: compute all subcohorts causal effects and compositions
    pb = txtProgressBar(min = 1, max = number_cohorts, initial = 1) 
    
    for (i in 1:number_cohorts){
      
      setTxtProgressBar(pb, i)
      cohort_i <- filter(super_populations, PATIENT_ID %in% sample_patients[,i]) %>%
        filter(!is.na(Y_PM))
        
      #SUBCOHORT COMPOSITION2: Compute compositions (in C_i and k_i) of subcohorts o later analyse potential biases
      #First for CE1 cohorts
      res[i, paste0("Prop_CE1_", list_genes)] <- filter(cohort_i, PM==1 | A==0) %>% select(one_of(list_genes)) %>% colMeans
      
      res[i, paste0("Prop_CE1_", list_treatments)] <- filter(cohort_i, PM==1 | A==0) %>%
        group_by(K_PM, .drop=FALSE) %>%
        summarise(prop=n()/nrow(.)) %>% .$prop
      
      res[i, paste0("Diff_CE1_", list_genes)] <- (filter(cohort_i, PM==1) %>%
                                                    select(one_of(list_genes)) %>% colMeans) -
        (filter(cohort_i, A==0) %>%
           select(one_of(list_genes)) %>% colMeans)
      
      res[i, paste0("Diff_CE1_", list_treatments)] <- (filter(cohort_i, PM==1) %>% group_by(K_PM, .drop=FALSE) %>% summarise(prop=n()/nrow(.)) %>% .$prop) -
          (filter(cohort_i, A==0) %>% group_by(K_PM, .drop=FALSE) %>% summarise(prop=n()/nrow(.)) %>% .$prop)
      
      #Then for CE2 cohorts
      res[i, paste0("Prop_CE2_", list_genes)] <- filter(cohort_i, PM==1 | A==1) %>%
        select(one_of(list_genes)) %>% colMeans
      
      res[i, paste0("Prop_CE2_", list_treatments)] <- filter(cohort_i, PM==1 | A==1) %>%
        group_by(K_PM, .drop=FALSE) %>%
        summarise(prop=n()/nrow(.)) %>% .$prop
      
      res[i, paste0("Diff_CE2_", list_genes)] <- (filter(cohort_i, PM==1) %>% select(one_of(list_genes)) %>% colMeans) -
        (filter(cohort_i, A==1) %>% select(one_of(list_genes)) %>% colMeans)
      
      res[i, paste0("Diff_CE2_", list_treatments)] <- (filter(cohort_i, PM==1) %>% group_by(K_PM, .drop=FALSE) %>% summarise(prop=n()/nrow(.)) %>% .$prop) -
        (filter(cohort_i, A==1) %>% group_by(K_PM, .drop=FALSE) %>%
           summarise(prop=n()/nrow(.)) %>% .$prop)
        
      #Finally for CE3 cohorts
      res[i, paste0("Prop_CE3_", list_genes)] <- res[i, paste0("Prop_CE2_", list_genes)]
      res[i, paste0("Prop_CE3_", list_treatments)] <- res[i, paste0("Prop_CE2_", list_treatments)]
      res[i, paste0("Diff_CE3_", list_genes)] <-res[i, paste0("Diff_CE2_", list_genes)]
      res[i, paste0("Diff_CE3_", list_treatments)] <- res[i, paste0("Diff_CE2_", list_treatments)]
        
      #TRUE EFFECTS: Compute the true effects in the subcohort using counterfactual data
      res[i, paste0("CE", 1:3, "_True")] <- true_effects(cohort_i)
        
      #NAIVE EFFECTS: Compute the naive effects in the subcohort using only observed data
      res[i, "CE1_Naive"] <- mean(filter(cohort_i, PM==1)$Y) - mean(filter(cohort_i, A==0)$Y)
      res[i, "CE2_Naive"] <- mean(filter(cohort_i, PM==1)$Y) - mean(filter(cohort_i, A==1)$Y)
      res[i, "CE3_Naive"] <- mean(filter(cohort_i, PM==1)$Y) -
        filter(cohort_i, A==1) %>% group_by(K) %>% summarise(Mean=mean(Y)) %>% .$Mean %>% mean
        
      #STANDARDIZATION: fit outcome models to estimate the counterfactual variables for later use in quantification of causal effects
      #Y_1_KPM: estimate the counterfactual outcome corresponding to all patients treated according to PM algorithm (used in CE1, CE2 and CE3)
      cohort_i_std <- mutate(cohort_i, K_1KPM=K)
      std1 <- glm(as.formula(paste0("Y ~ K_1KPM*(",
                                    paste0(list_genes, collapse = "+"),
                                    ")")),
                  #Y ~ K_1KPM*(C_1 + C_2 + C_3),
                  data = cohort_i_std,
                  family = fam)
      cohort_i_std %<>% mutate(K_1KPM=K_PM) %>%
        mutate(Y_1KPM=predict(std1, ., type="response"))
      
      #Y_1_k1, Y_1_k2 and Y_1_k3: estimate the counterfactual outcome corresponding to all patients treated with k1/k2/k3
      for (t in list_treatments){
        cohort_i_std[,paste0("Y_1_", t)] <- predict.glm(std1, mutate(cohort_i_std, K_1KPM=t), type="response")
      }

      #Y_1_krand: estimate the counterfactual outcome corresponding to all patients treated with random treatment among k1/k2/k3 (for CE3)
      cohort_i_std[,"Y_1_krand"] <- cohort_i_std[, paste0("Y_1_", list_treatments)] %>% rowMeans

      #Y_0_k0: estimate the counterfactual outcome corresponding to all patients left untreated (for CE1)
      cohort_i_std %<>% mutate(A_01=A)
      std2 <- glm(as.formula(paste0("Y ~ A_01*(",
                                    paste0(list_genes, collapse = "+"),
                                    ")")),
                  #Y ~ A_01*(C_1 + C_2 + C_3),
                  data = cohort_i_std,
                  family = fam)
      cohort_i_std %<>% mutate(A_01=0) %>%
        mutate(Y_0_k0=predict.glm(std2, ., type = "response"))
      #Y_1_K: estimate the counterfactual outcome corresponding to all patients treated with physician's treatment (for CE2)
      cohort_i_std %<>% mutate(A_01=1) %>%
        mutate(Y_1_K=predict.glm(std2, ., type = "response"))
      
      #Write causal effects: estimate the causal effects
      res[i, "CE1_Std"] <- mean(cohort_i_std$Y_1KPM)-mean(cohort_i_std$Y_0_k0)
      res[i, "CE2_Std"] <- mean(cohort_i_std$Y_1KPM)-mean(cohort_i_std$Y_1_K)
      res[i, "CE3_Std"] <- mean(cohort_i_std$Y_1KPM)-mean(cohort_i_std$Y_1_krand)
      
      #IPW ESTIMATES: fit treatment models
      #Fit IPW models for CE1 and CE2
      #Weights for PM=1 arm
      cohort_i_ipw <- cohort_i
      
      #Weights for A=0 arm
      ipw_A_denom <- glm(as.formula(paste0("A ~ ",
                                            paste0(list_genes, collapse = "+"))),
                          data = cohort_i_ipw,
                          family = binomial(link = "logit")) %>%
        predict(type="response")
      ipw_A_nom <- mean(cohort_i_ipw$A)
      
      cohort_i_ipw %<>% mutate(SW_A=if_else(A==1, ipw_A_nom/ipw_A_denom, 
                                             (1-ipw_A_nom)/(1-ipw_A_denom)),
                               W_A=if_else(A==1, 1/ipw_A_denom, 1/(1-ipw_A_denom)))
      
      #Fit IPW models for CE3
      ipw_K_denom <- multinom(as.formula(paste0("K ~ ",
                                                paste0(list_genes, collapse = "+"))),
                              data = cohort_i_ipw, trace=FALSE) %>%
        predict(type="probs")
      ipw_K_num <- multinom(K~1,
                            data = cohort_i_ipw, trace=FALSE) %>%
        predict(type="probs")
      
      for (t in list_treatments){
        cohort_i_ipw %<>% mutate(UQ(paste0("SW_", t)) := ipw_K_num[,t]/ipw_K_denom[,t],
                                 UQ(paste0("W_", t)) := 1/ipw_K_denom[,t])
      }
      Y_IPW_rand <- sapply(list_treatments,
                           function(x) mean((cohort_i_ipw$K==x)*cohort_i_ipw[,paste0("SW_", x)]*cohort_i_ipw$Y) /
                             mean((cohort_i_ipw$K==x)*cohort_i_ipw[,paste0("SW_", x)]))
      
      #Test for versions
      cohort_i_ipw %<>% mutate(SW_PM=mapply(function(x,y) if (is.na(y)) {NA_real_}
                                             else {
                                               .[x, paste0("SW_", y)]
                                               },
                                             1:nrow(.), .$K_PM) %>% unlist,
                               W_PM=mapply(function(x,y) if (is.na(y)) {NA_real_}
                                             else {
                                               .[x, paste0("W_", y)]
                                               },
                                             1:nrow(.), .$K_PM) %>% unlist)
      
       #Write causal effects
      t_PM <- mean(with(cohort_i_ipw, PM*SW_PM*Y)) / mean(with(cohort_i_ipw, PM*SW_PM))
      res[i, "CE1_IPW"] <- t_PM - (mean(with(cohort_i_ipw, (1-A)*SW_A*Y)) / mean(with(cohort_i_ipw, (1-A)*SW_A)))
      res[i, "CE2_IPW"] <- t_PM - (mean(with(cohort_i_ipw, A*SW_A*Y)) / mean(with(cohort_i_ipw, A*SW_A)))
      res[i, "CE3_IPW"] <- t_PM - mean(Y_IPW_rand)
      
      #TMLE ESTIMATE WITH GLM
      #First compute the Q0 model based on K
      cohort_i_tmle <- mutate(cohort_i, K_1KPM=K)
    
      tl_glm1 <- glm(as.formula(paste0("Y ~ K_1KPM*(",
                                       paste0(list_genes, collapse = "+"),
                                       ")")),
                data = cohort_i_tmle,# %>% filter(K_1KPM!="LEE011"),
                family = fam)
    
      cohort_i_tmle %<>% mutate(K_1KPM=K_PM) %>%
        mutate(Q0_KPM=predict.glm(std1, ., type="response"),
               Q0_K=predict.glm(std1, type="response"))
      
      for (t in list_treatments){
        cohort_i_tmle[,paste0("Q0_K", t)] <- predict.glm(tl_glm1, mutate(cohort_i_tmle, K_1KPM=t), type="response")
      }

    #And based on A
    cohort_i_tmle %<>% mutate(A_01=A)
    tl_glm2 <- glm(as.formula(paste0("Y ~ A_01*(",
                                     paste0(list_genes, collapse = "+"),
                                  ")")),
                data = cohort_i_tmle,
                family = fam)
    
    cohort_i_tmle %<>% mutate(A_01=0) %>%
      mutate(Q0_A0=predict.glm(tl_glm2, ., type="response"),
             Q0_A=predict.glm(tl_glm2, type="response")) %>%
      mutate(A_01=1) %>%
      mutate(Q0_A1=predict.glm(tl_glm2, ., type="response"))
    
    #Compute propensity scores
    prop_A <- glm(as.formula(paste0("A ~ ",
                                    paste0(list_genes, collapse = "+"))),
                  data = cohort_i_tmle,
                  family = binomial(link = "logit")) %>%
      predict(type="response") %>% unname
    cohort_i_tmle %<>% mutate(gA=if_else(A==1, prop_A, 1-prop_A))
    
    prop_K <- multinom(as.formula(paste0("K ~ ",
                                         paste0(list_genes, collapse = "+"))),
                       data = cohort_i_tmle, trace=FALSE) %>%
      predict(type="probs")
    
    for (t in list_treatments){
      cohort_i_tmle %<>% mutate(UQ(paste0("gK_", t)) := unname(prop_K[,t]))
    }
    
    cohort_i_tmle %<>% mutate(gKPM=mapply(function(x,y) if (is.na(y)) {NA_real_}
                                         else {
                                           unname(.[x, paste0("gK_", y)])
                                         },
                                         1:nrow(.), .$K_PM) %>% unlist)
    
    #CE1 estimation
    cohort_i_tmle_CE1 <- mutate(cohort_i_tmle,
                                CE1=if_else(A==0, 0, if_else(PM==1, 1, NA_real_))) %>%
      filter(!is.na(CE1)) %>%
      mutate(H1=if_else(CE1==1, 1/gKPM, 0),
             H0=if_else(CE1==0, 1/(1-gA), 0))
    
    # cohort_i_tmle_CE1 <- mutate(cohort_i_tmle,
    #                             CE1=if_else(A==0, 0, if_else(PM==1, 1, NA_real_))) %>%
    #   filter(!is.na(CE1)) %>%
    #   mutate(H1=1/gKPM,
    #          H0=-1/(1-gA),
    #          HN=CE1/gKPM - (1-CE1)/(1-gA))
    
    if (bin==FALSE){
    fit <- glm(Y ~ -1 + H0 + H1 + offset(Q0_K),
               data = cohort_i_tmle_CE1,
               family = fam) %>%
      coef
    
    cohort_i_tmle_CE1 %<>% mutate(Q1_A0=Q0_A0+fit[1]*H0,
                             Q1_KPM=Q0_KPM+fit[2]*H1)
    } else {
      fit <- glm(Y ~ -1 + H0 + H1 + offset(qlogis(Q0_K)),
              #glm(Y ~ -1 + H0 + H1 + offset(Q0_K),
               data = cohort_i_tmle_CE1,
               family = fam) %>%
        coef
      cohort_i_tmle_CE1 %<>% mutate(Q1_A0=plogis(qlogis(Q0_A0)+fit[1]*H0),
                             Q1_KPM=plogis(qlogis(Q0_KPM)+fit[2]*H1))
      
      # fit <- glm(Y ~ -1 + HN + offset(qlogis(Q0_K)),
      #         #glm(Y ~ -1 + H0 + H1 + offset(Q0_K),
      #          data = cohort_i_tmle_CE1,
      #          family = fam) %>%
      #   coef
      # cohort_i_tmle_CE1 %<>% mutate(Q1_A0=plogis(qlogis(Q0_A0)+fit*H0),
      #                        Q1_KPM=plogis(qlogis(Q0_KPM)+fit*H1))
    }
    
    res[i, "CE1_TMLE"] <- with(cohort_i_tmle_CE1, mean(Q1_KPM-Q1_A0))
    
    #CE2 estimation
    cohort_i_tmle_CE2 <- bind_rows(filter(cohort_i_tmle, PM==1) %>% mutate(CE2=1),
                                   filter(cohort_i_tmle, A==1) %>% mutate(CE2=0)) %>%
      mutate(H1=if_else(CE2==1, 1/gKPM, 0),
             H0=if_else(CE2==0, 1/(gA), 0))
    
    if (bin==FALSE){
    fit <- glm(Y ~ -1 + H0 + H1 + offset(Q0_K),
               data = cohort_i_tmle_CE2,
               family = fam) %>%
      coef
    
    cohort_i_tmle_CE2 %<>% mutate(Q1_A1=Q0_A1+fit[1]*H0,
                             Q1_KPM=Q0_KPM+fit[2]*H1)
    } else {
      fit <- glm(Y ~ -1 + H0 + H1 + offset(qlogis(Q0_K)),
              #glm(Y ~ -1 + H0 + H1 + offset(Q0_K),
               data = cohort_i_tmle_CE2,
               family = fam) %>%
        coef
      cohort_i_tmle_CE2 %<>% mutate(Q1_A1=plogis(qlogis(Q0_A1)+fit[1]*H0),
                             Q1_KPM=plogis(qlogis(Q0_KPM)+fit[2]*H1))
    }
    
    res[i, "CE2_TMLE"] <- with(cohort_i_tmle_CE2, mean(Q1_KPM-Q1_A1))
    
    #CE3 estimation
    cohort_i_tmle_CE3 <- bind_rows(filter(cohort_i_tmle, PM==1) %>% mutate(CE3=1),
                                   filter(cohort_i_tmle, A==1) %>% mutate(CE3=0)) %>%
      mutate(H1=if_else(CE3==1, 1/gKPM, 0))
    
    for (t in list_treatments){
      cohort_i_tmle_CE3[,paste0("H0_", t)] <- if_else(cohort_i_tmle_CE3$K==t, 1/cohort_i_tmle_CE3[,paste0("gK_", t)], 0)
    
      if (bin==FALSE){
      fit <- glm(as.formula(paste0("Y ~ -1 + H0_", t," + H1 + offset(Q0_K)")),
                 data = cohort_i_tmle_CE3,
                 family = fam) %>%
        coef
      
      cohort_i_tmle_CE3[,paste0("Q1_K", t)] <-
        cohort_i_tmle_CE3[,paste0("Q0_K", t)]+fit[1]*cohort_i_tmle_CE3[,paste0("H0_", t)]
      cohort_i_tmle_CE3[,paste0("Q1_KPM", t)] <-
        cohort_i_tmle_CE3[,"Q0_KPM"]+fit[2]*cohort_i_tmle_CE3[,"H1"]

      } else {
        fit <- glm(as.formula(paste0("Y ~ -1 + H0_", t," + H1 + offset(qlogis(Q0_K))")),
                #glm(as.formula(paste0("Y ~ -1 + H0_", t," + H1 + offset(Q0_K)")),
                   data = cohort_i_tmle_CE3,
                   family = fam) %>%
          coef
        
        cohort_i_tmle_CE3[,paste0("Q1_K", t)] <-
          plogis(qlogis(cohort_i_tmle_CE3[,paste0("Q0_K", t)])+fit[1]*cohort_i_tmle_CE3[,paste0("H0_", t)])
        cohort_i_tmle_CE3[,paste0("Q1_KPM", t)] <-
          plogis(qlogis(cohort_i_tmle_CE3[,"Q0_KPM"])+fit[2]*cohort_i_tmle_CE3[,"H1"])
      
      }
      
      cohort_i_tmle_CE3[, paste0("CE3_", t)] <- cohort_i_tmle_CE3[, paste0("Q1_KPM", t)]-
        cohort_i_tmle_CE3[, paste0("Q1_K", t)]
      
    }
    
    res[i, "CE3_TMLE"] <- colMeans(select(cohort_i_tmle_CE3, starts_with("CE3_"))) %>% mean

    }
    
    res
  
}

print("Done")
```

## Visualize results and biases

Last, we define the *plot_CE* and *plot_CE_summary* functions to visualize the values of our causal estimates

```{r PM_random_plots, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE, fig.height = 8, fig.width = 10}

colors_methods <- c("True"= "#376597FF", "Std"="#928F6BFF", "IPW"="#CCAF69FF",
                    "TMLE"="#556246FF",
                    "Naive"="#8F5144FF")

#input_data <- sim_data1_random
#CEi <- "CE1"
#te <- true_effects(sim_data1)
plot_CE <- function(input_data, CEi, te){
  te_CEi <- te[CEi] %>% unlist %>% unname
  
  plot_data <- select(input_data, Cohort, starts_with(CEi)) %>%
      rename_all(funs(str_replace(., paste0(CEi,"_"), ""))) %>%
      mutate(TE=te_CEi)
  
  #Distributions of CE1 estimates
    p_distrib <-  pivot_longer(plot_data, any_of(c("True", "Naive", "Std", "IPW", "TMLE")),
                               names_to = "Method", values_to = "Estimate") %>%
      mutate(Method=factor(Method,
                           levels=c("True", "TMLE", "Std", "IPW", "Naive"))) %>%
      ggplot(aes(x=Method, y=Estimate, fill=Method)) +
      geom_boxplot(alpha=1, show.legend = FALSE, varwidth = FALSE, width=0.4) +
      geom_text(data = . %>% filter(!is.nan(Estimate)) %>% group_by(Method) %>%
                  summarise(N=paste0("n=",n()), Min=min(Estimate), Max=max(Estimate)) %>%
                  mutate(Estimate=min(Min)-0.05*(max(Max)-min(Min))),
                aes(x=Method, label=N), size=3) +
      scale_fill_manual(values=colors_methods) +
      geom_hline(aes(linetype="True effect in\nsuper-population",
                     yintercept = TE)) +
      scale_linetype_manual(name="Reference",
                            values=c("True effect in\nsuper-population"="dashed"),
                            guide = guide_legend(direction = "vertical")) +
      labs(title=paste0(CEi," distribution and methods")) +
      theme_pubclean() +
      theme(legend.justification = "center",
              legend.text = element_text(size=8),
              legend.title = element_text(face="bold", size=10))
    
    #Deviations
    p_diff <-pivot_longer(plot_data, any_of(c("Naive", "Std", "IPW", "TMLE")),
                          names_to = "Method", values_to = "Estimate") %>%
      mutate(Method=factor(Method, levels=c("TMLE", "Std", "IPW", "Naive")),
             Diff=Estimate-True) %>%
      ggplot(aes(x=Method, y=Diff, fill=Method)) +
      geom_boxplot(alpha=1, show.legend = FALSE, varwidth = FALSE, width=0.4) +
      scale_fill_manual(values=colors_methods) +
      labs(title=paste0(CEi," deviations from true effects"),
           y="Deviation value") +
      theme_pubclean() +
      theme(legend.position = "bottom",
        legend.title = element_text(face="bold"))
    
    #Performances
    p_perf_plot <-pivot_longer(plot_data, any_of(c("Naive", "Std", "IPW", "TMLE")),
                          names_to = "Method", values_to = "Estimate") %>%
      mutate(Method=factor(Method, levels=c("TMLE", "Std", "IPW", "Naive"))) %>%
      group_by(Method) %>%
      summarise(RMSE=RMSE(True, Estimate, na.rm=TRUE), MAE=MAE(True, Estimate, na.rm=TRUE))
    
      p_perf <- mutate(p_perf_plot, Label=as.character(round(MAE, digits=2))) %>%
        ggplot(aes(x=Method, y=MAE, fill=Method)) +
        geom_bar(stat = "identity", width=0.5) +
        geom_text(aes(label=Label, y=0.5*min(MAE)), color="white") +
        scale_fill_manual(values=colors_methods, guide = guide_legend(direction = "vertical")) +
        theme_pubclean() +
        theme(legend.justification = "center",
              legend.text = element_text(size=8),
              legend.title = element_text(face="bold", size=10))
    
    #Scatter plot for estimates
    # p_scatter <- pivot_longer(plot_data, any_of(c("Naive", "Std", "IPW", "TMLE")),
    #                           names_to = "Method", values_to = "Estimate") %>%
    #   mutate(Method=factor(Method, levels=c("TMLE", "Std","IPW", "Naive"))) %>%
    #   ggplot(aes(x=True, y=Estimate)) +
    #   geom_point(aes(color=Method), size=0.6, show.legend = FALSE) +
    #   geom_abline(aes(slope = 1, intercept = 0, linetype = "y = x"),
    #               lwd=1,show.legend=TRUE) +
    #   geom_smooth(method = "lm", formula =y ~ x, aes(linetype = "y = ax+b"),
    #               color="black",show.legend=FALSE) +
    #   stat_cor(aes(label = `..r.label..`), p.digits =1, label.sep = '\n') +
    #   facet_grid(.~Method)  +
    #   scale_color_manual(values=c(colors_methods)) +
    #   scale_linetype_manual(values= c("y = x"="solid", "y = ax+b"="dashed"),
    #                         guide = guide_legend(direction = "vertical",
    #                                              override.aes=list(fill=NA))) +
    #   labs(title = paste0(CEi," estimates compared to true effects"),
    #        x="True estimates",
    #        y="Estimates from\nobserved data",
    #        linetype="Lines") +
    #   theme_pubclean() +
    #   theme(legend.justification = "center",
    #         legend.text = element_text(size=8),
    #         legend.title = element_text(face="bold", size=10)) +
    #   guides(color=FALSE)
    
    #((p_distrib / (p_diff + p_perf) / p_scatter) | guide_area()) +
    #  plot_layout(guides = 'collect', widths = c(6,1))
    
    ((p_distrib / (p_diff + p_perf)) | guide_area()) +
      plot_layout(guides = 'collect', widths = c(6,1))
  
}

plot_CE_summary <- function(input_data, te){
  
  plot_CEx <- function(CEi){
  val <- gsub("CE", "", CEi)
  plot_data_CEi <- select(input_data, Cohort, starts_with(CEi)) %>%
      rename_all(funs(str_replace(., paste0(CEi,"_"), ""))) %>%
      mutate(TE=te[CEi] %>% unlist %>% unname)
  
  if (CEi=="CE3"){
  p_distrib <-  pivot_longer(plot_data_CEi, any_of(c("True", "Naive", "Std", "IPW", "TMLE")),
                               names_to = "Method", values_to = "Estimate") %>%
      mutate(Method=factor(Method,
                           levels=c("True", "TMLE", "Std", "IPW", "Naive"))) %>%
      ggplot(aes(x=Method, y=Estimate, fill=Method)) +
      geom_boxplot(alpha=1, show.legend = FALSE, varwidth = FALSE, width=0.4) +
      scale_fill_manual(values=colors_methods) +
      geom_hline(aes(linetype="True effect\n in super-\npopulation",
                     yintercept = TE)) +
      scale_linetype_manual(name="Reference",
                            values=c("True effect\n in super-\npopulation"="dashed"),
                            guide = guide_legend(direction = "vertical")) +
      labs(title=bquote(CE[.(val)] ~ " distributions")) +
      theme_pubclean() +
      theme(plot.title = element_text(size = 10, face = 'bold'),
            legend.position = "bottom",
            legend.text = element_text(size=8),
            legend.title = element_text(face="bold", size=10),
            legend.justification = "center",
            axis.title.x = element_blank(),
            axis.title.y = element_text(size=10),
            legend.key = element_rect(fill = NA, colour = NA))
  } else {
    p_distrib <-  pivot_longer(plot_data_CEi, any_of(c("True", "Naive", "Std", "IPW", "TMLE")),
                               names_to = "Method", values_to = "Estimate") %>%
      mutate(Method=factor(Method,
                           levels=c("True", "TMLE", "Std", "IPW", "Naive"))) %>%
      ggplot(aes(x=Method, y=Estimate, fill=Method)) +
      geom_boxplot(alpha=1, show.legend = FALSE, varwidth = FALSE, width=0.4) +
      scale_fill_manual(values=colors_methods) +
      geom_hline(aes(linetype="True effect in super-population",
                     yintercept = TE), show.legend = FALSE) +
      scale_linetype_manual(name="Reference",
                            values=c("True effect in super-population"="dashed")) +
      labs(title=bquote(CE[.(val)] ~ " distributions")) +
      theme_pubclean() +
      theme(plot.title = element_text(size = 10, face = 'bold'),
            axis.title.x = element_blank(),
            axis.title.y = element_text(size=10))
  }
  
  #Deviations
  p_diff <-pivot_longer(plot_data_CEi, any_of(c("Naive", "Std", "IPW", "TMLE")),
                        names_to = "Method", values_to = "Estimate") %>%
    mutate(Method=factor(Method, levels=c("TMLE", "Std", "IPW", "Naive")),
           Diff=Estimate-True) %>%
    ggplot(aes(x=Method, y=Diff, fill=Method)) +
    geom_boxplot(alpha=1, show.legend = FALSE, varwidth = FALSE, width=0.4) +
    scale_fill_manual(values=colors_methods) +
    labs(title=bquote(CE[.(val)] ~ " deviations"),
         y="Deviation value") +
    theme_pubclean() +
    theme(plot.title = element_text(size = 10, face = 'bold'),
      legend.position = "bottom",
      legend.title = element_text(face="bold"),
      axis.title.x = element_blank(),
       axis.title.y = element_text(size=10)
    )
  
  #Performances
    p_perf_plot <-pivot_longer(plot_data_CEi, any_of(c("Naive", "Std", "IPW", "TMLE")),
                          names_to = "Method", values_to = "Estimate") %>%
      mutate(Method=factor(Method, levels=c("TMLE", "Std", "IPW", "Naive"))) %>%
      group_by(Method) %>%
      summarise(RMSE=RMSE(True, Estimate, na.rm=TRUE), MAE=MAE(True, Estimate, na.rm=TRUE))
    
      p_perf <- mutate(p_perf_plot, Label=as.character(round(MAE, digits=2))) %>%
        ggplot(aes(x=Method, y=MAE, fill=Method)) +
        geom_bar(stat = "identity", width=0.8,
                 show.legend = if_else(CEi=="CE3", TRUE, FALSE)) +
        geom_text(aes(label=Label, y=0.5*min(MAE)), color="white",
                  fontface="bold") +
        scale_fill_manual(values=colors_methods,
                          guide = guide_legend(direction = "vertical")) +
        labs(title=bquote(CE[.(val)] ~ " deviations scores")) +
        theme_pubclean() +
        theme(plot.title = element_text(size = 10, face = 'bold'),
              #legend.justification = "center",
              legend.text = element_text(size=8),
              legend.title = element_text(face="bold", size=10),
              axis.title.x = element_blank(),
              axis.title.y = element_text(size=10))
      
      p <- (p_distrib | p_diff | p_perf) +
        plot_layout(widths = c(5,4,5))
      
      return(p)
  }
  
  p_CE1 <- plot_CEx("CE1")
  p_CE2 <- plot_CEx("CE2")
  p_CE3 <- plot_CEx("CE3")
  
  ((p_CE1 / p_CE2 / p_CE3) | guide_area()) +
    plot_layout(widths = c(6,1), guides = 'collect')
}

print("Done")
```

# First scenario: random assignment of observed treatments

## Generic settings

For each counterfactual variable of response $Y(k^i)$ (simplified as $Y_i$), we define the intercept and the linear regression coefficients. As explained previously, lower intercept corresponds to better responses/more efficient drugs. Similarly, a negative regression coefficient between $Y(k^i)$ and $C_j$ means that the gene $C_j$ improves the response to $k^i$. Below we summarize the intercepts and regression coefficients of the simulation scenario.

```{r scenario1_table, echo=FALSE, message=FALSE, warning=FALSE}

df <- data.frame(Intercept=c(0, -25, 0), C_1=c(0, -15, 0), C_2=c(15, 10, -20))
rownames(df) <- c("Y_0", "Y_1", "Y_2")

knitr::kable(df) %>%
  kable_styling() %>%
  add_header_above(c(" " = 2, "Linear regr. coeff." = 2))

```

So all in all, $k^1$ has the best basal response (lowest intercept). $C_1$ (resp. $C_2$) improves the response to $k^1$ (resp. $k^2$), in line with the definition of the treatment algorithm.

## Scenario 1

On top of that, for this first simulation scenario, observed treatments are assigned randomly with equal probabilities.

```{r scenario1_generate, echo=FALSE, message=FALSE, warning=FALSE}
#Let's use the lava package
m1 <- lvm()

#Define nature of variables
#Agressiveness: corresponds to confounding factors of response. Indeed, in PDX you can observe a correlation between response when treated and response when untreated, meaning that some tumours are "intrinsically" more aggressive than others whatever the treatment status
latent(m1) <- ~Aggressiveness

#C_i (or Genes): Binary mutational status for all genes. Same prevalence. Potential overlaps between mutations
distribution(m1,~C_1 + C_2) <- binomial.lvm(p=0.4)

#K: Version of treatment. In this case, randomly assigned without any regard to patient profile
#A: Treatment status. Has patient been treated (A=1) or not (A=0)
m1 <- categorical(m1, ~K, 3, p=c(1/3, 1/3, 1/3),
                  labels=c("k_0", "k_1","k_2"))
transform(m1,A~K) <- function(x){
  if_else(x[["K"]]=="k_0", 0, 1)
}

#Y_i: Reponse when treated by drug k_i. Depends on Aggressiveness and C_i
regression(m1, Y_0 ~ Aggressiveness + C_2) <- c(10, 15)
intercept(m1, ~Y_0) <- 0

regression(m1, Y_1 ~ Aggressiveness + C_1 + C_2) <- c(10, -15, 10)
intercept(m1, ~Y_1) <- -25

regression(m1, Y_2 ~ Aggressiveness + C_2) <-c(10, -20)
intercept(m1, ~Y_2) <- 0
covariance(m1, ~Y_0 + Y_1 + Y_2) <- 25

transform(m1,K_PM~C_1+C_2) <- function(x){
  case_when(x[["C_1"]]==1 ~ "k_1",
            x[["C_2"]]==1 ~ "k_2",
            TRUE ~ "None")
}

#Generate data
process_sim_data <- function(df){
  res <- mutate(df, Y_PM=
                  if_else(K_PM=="k_1", Y_1,
                          if_else(K_PM=="k_2", Y_2, NA_real_))) %>%
    mutate(Y=
             if_else(K=="k_1", Y_1,
                     if_else(K=="k_2", Y_2, Y_0))) %>%
    mutate(Y_Random=(Y_1+Y_2)/2,
           PM = if_else(K_PM == K, 1, 0)) %>%
    rownames_to_column(var="PATIENT_ID")
}

set.seed(1)
sim_data1 <- sim(m1,10000) %>% process_sim_data

#plot(m1, labels = T, diag = T)

```

Here are some plots and models to summarize the nature of generated data.

```{r scenario1_visualize, echo=FALSE, fig.height=8, fig.width=16, message=FALSE, warning=FALSE}

simulated_data_plot(sim_data1)

```

On the above plot we observe a comprehensive landscape on the nature of the simulated data (from left to right) :

  * The different combinations of mutations in $C_1$/$C_2$
  * Their respective influence on the values of Y_0/Y_1/Y_2/Y_PM with a boxplot for the distribution of response for each drug and each combination of mutations
  * Last, in the Sankey plot, a size of each subcohort (as a percentage of the whole cohort of 10'000 patients), their assignment of a specific personalized drug (K_PM) and their observed assignment based on physician's choice in the observed data (K)
  
In this case we can observe similar prevalence of mutations. Y_i responses are, as expected, decreased when the corresponding biomarker C_i is mutated. Last, in the Sankey plot we observe the deterministic assignment of K_PM based on mutational status (from first strata to 2nd strata) and then the random assignemnt of observed treatments assigned by the clinician (equal subdivisions in all categories, from 2nd strata to 3rd strata)
  
```{r scenario1_additional, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE}
#Additional plot
ggplot(sim_data1, aes(x=Y_0, y=Y_1, group=C_1, color=as.factor(C_1))) +
  geom_point(alpha=0.5) +
  stat_cor() +
  geom_smooth(method=lm, formula = y~x) +
  labs(title = "Correlation Y_1/Y_0 due to latent Aggressiveness",
       x = "Y_0 (untreated)",
       y = "Y_1",
       color = "Status of C_1")
```

## True effects

First we compute the true effects on the whole population.

```{r scenario1_true, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE}

true_effects1 <- true_effects(sim_data1)

```

The benefit of PM treatment strategy is :

  * `r true_effects1$CE1` compared with untreated (CE1)
  * `r true_effects1$CE2` compared with really assigned treatment in data (CE2)
  * `r true_effects1$CE3` compared with random assignment of treatment (CE3)
  
Please note that in this simple case, real treatments have indeed been defined randomly so it makes sense that $CE\_2=CE\_3$.

## Effects on random cohorts

Now, let's sample random cohorts from the original super-population to see whether we are able to recover the true value. 

We samples 1000 different cohorts of 200 individuals from our super-population. Then we focus only on PM-eligible patients (the ones with a covariate/biomarker combinations resulting in a personalized treatment assigned by the PM algorithm) and compute the following effects:

For **CE1** , **CE2**  and **CE3** we compute:

  * True effect: using counterfactuals for all patients
  * Naive effect: using observed outcome for both arms
  * IPW, standardized and TMLE effects: using observed outcome, corrected by the mentioned method
    
  
```{r scenario1_random, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE}
sim_data1_random <- random_cohorts(sim_data1)
print("Done")
```

## Plots

Now let's visualize the respective performance of the methods for the different effects

### Summary plot


```{r scenario1_summary, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE, fig.height = 8, fig.width = 10}

plot_CE_summary(sim_data1_random, true_effects1)

```


### CE1


```{r scenario1_CE1, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE, fig.height = 8, fig.width = 10}

plot_CE(sim_data1_random, "CE1", true_effects1)

```

What can we deduce from these plots?

### CE2

```{r scenario1_CE2, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE, fig.height = 8, fig.width = 10}

plot_CE(sim_data1_random, "CE2", true_effects1)

```

### CE3

```{r scenario1_CE3, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE, fig.height = 8, fig.width = 10}

plot_CE(sim_data1_random, "CE3", true_effects1)

```

# Second scenario

This second scenario is similar to the first one, except for the assignment of observed treatment. Since $k^1$ has a better basal response, we imagine that it is given with greater probability, regardless of the molecular profiles of patients. Therefore, in the observed data, the probability of having been treated by $k^1$ is 0.5 and only 0.25 for $k^0$ and $k^2$.

```{r scenario2_generate, eval=TRUE, echo=FALSE, fig.height=8, fig.width=16, message=FALSE, warning=FALSE}

m2 <- lvm()
latent(m2) <- ~Aggressiveness

distribution(m2,~C_1 + C_2) <- binomial.lvm(p=0.4)

m2 <- categorical(m2, ~K, 3, p=c(1/4, 1/2, 1/4),
                  labels=c("k_0", "k_1","k_2"))
transform(m2,A~K) <- function(x){
  if_else(x[["K"]]=="k_0", 0, 1)
}

#Y_i: Reponse when treated by drug k_i. Depends on Aggressiveness and C_i
regression(m2, Y_0 ~ Aggressiveness + C_2) <- c(10, 15)
intercept(m2, ~Y_0) <- 0

regression(m2, Y_1 ~ Aggressiveness + C_1 + C_2) <- c(10, -15, 10)
intercept(m2, ~Y_1) <- -25

regression(m2, Y_2 ~ Aggressiveness + C_2) <-c(10, -20)
intercept(m2, ~Y_2) <- 0
covariance(m2, ~Y_0 + Y_1 + Y_2) <- 25

transform(m2,K_PM~C_1+C_2) <- function(x){
  case_when(x[["C_1"]]==1 ~ "k_1",
            x[["C_2"]]==1 ~ "k_2",
            TRUE ~ "None")
}

set.seed(1)
sim_data2 <- sim(m2,10000) %>% process_sim_data

#plot(m2, labels = T, diag = T)


```

Now let's compute our causal effects.

```{r scenario2_random, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE}
true_effects2 <- true_effects(sim_data2)
publish(true_effects2)

sim_data2_random <- random_cohorts(sim_data2)
print("Done")
```

## Summary

```{r scenario2_summary, echo=FALSE, message=FALSE, warning=FALSE,  fig.height = 8, fig.width = 10, eval=TRUE}
plot_CE_summary(sim_data2_random, true_effects2)
```

## CE1

```{r scenario2_CE1, echo=FALSE, message=FALSE, warning=FALSE,  fig.height = 8, fig.width = 10, eval=TRUE}
plot_CE(sim_data2_random, "CE1", true_effects2)
```

## CE2

```{r scenario2_CE2, echo=FALSE, message=FALSE, warning=FALSE,  fig.height = 8, fig.width = 10, eval=TRUE}
plot_CE(sim_data2_random, "CE2", true_effects2)
```

## CE3

```{r scenario2_CE3, echo=FALSE, message=FALSE, warning=FALSE,  fig.height = 8, fig.width = 10, eval=TRUE}
plot_CE(sim_data2_random, "CE3", true_effects2)
```


```{r plots_paper, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE, fig.height = 8, fig.width = 10}

plot_scenario1 <- wrap_plots(simulated_data_plot(sim_data1),
                             plot_CE_summary(sim_data1_random, true_effects1),
                             nrow = 2, heights = c(1,2))

plot_scenario2 <- wrap_plots(simulated_data_plot(sim_data2),
                             plot_CE_summary(sim_data2_random, true_effects2),
                             nrow = 2, heights = c(1,2))


#ggsave(file="Simulation_Additional.svg", plot=plot_scenario1, width=9, height=8)

#ggsave(file="Simulation_Results.svg", plot=plot_scenario2, width=9, height=8)


```

# Second scenario: binary alternative

Here we adapt the second scenario to have binary outcomes. $Y=1$ correspond to responder and $Y=0$ to non-responders. 

```{r scenario_2bis, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE,  fig.height = 8, fig.width = 10}

values <- select(sim_data2, Y_0, Y_1, Y_2) %>% unlist
m <- mean(values)
s <- 2*sd(values)

binarize <- function(x){
  res <- pnorm(x, mean = m, sd=s) %>% rbernoulli(1, p=.) %>% `!`
  return(as.numeric(res))
}

sim_data3 <- mutate_at(sim_data2, c("Y_0", "Y_1", "Y_2"),
                       function(x) binarize(x))

sim_data3 <- sim_data2
for (i in 1:nrow(sim_data3)){
  sim_data3[i, "Y_0"] <- binarize(sim_data3[i, "Y_0"])
  sim_data3[i, "Y_1"] <- binarize(sim_data3[i, "Y_1"])
  sim_data3[i, "Y_2"] <- binarize(sim_data3[i, "Y_2"])
}
sim_data3 %<>% column_to_rownames(var="PATIENT_ID") %>% process_sim_data

```

Now let's compute our causal effects.

```{r scenario2bis_random, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE}
true_effects3 <- true_effects(sim_data3)
publish(true_effects3)

sim_data3_random <- random_cohorts(sim_data3, bin = TRUE)
print("Done")

plot_CE_summary(sim_data3_random, true_effects3)
```

```{r toc, echo=FALSE, message=FALSE, warning=FALSE,  fig.height = 8, fig.width = 10, eval=TRUE}
print("Computation done in:")
toc()
```